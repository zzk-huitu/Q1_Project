<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Extensible-calendar-view-AbstractCalendar'>/**
</span> * This is an abstract class that serves as the base for other calendar views. This class is not
 * intended to be directly instantiated.
 *
 * When extending this class to create a custom calendar view, you must provide an implementation
 * for the &lt;tt&gt;renderItems&lt;/tt&gt; method, as there is no default implementation for rendering events
 * The rendering logic is totally dependent on how the UI structures its data, which
 * is determined by the underlying UI template (this base class does not have a template).
 */
Ext.define(&#39;Extensible.calendar.view.AbstractCalendar&#39;, {
    extend: &#39;Ext.Component&#39;,

    requires: [
        &#39;Ext.CompositeElement&#39;,
        &#39;Extensible.calendar.form.EventDetails&#39;,
        &#39;Extensible.calendar.form.EventWindow&#39;,
        &#39;Extensible.calendar.menu.Event&#39;,
        &#39;Extensible.calendar.dd.DragZone&#39;,
        &#39;Extensible.calendar.dd.DropZone&#39;,
        &#39;Extensible.form.recurrence.RangeEditWindow&#39;
    ],

<span id='Extensible-calendar-view-AbstractCalendar-cfg-eventStore'>    /**
</span>     * @cfg {Ext.data.Store} eventStore
     * The {@link Ext.data.Store store} which is bound to this calendar and contains {@link Extensible.calendar.data.EventModel EventRecords}.
     * Note that this is an alias to the default {@link #store} config (to differentiate that from the optional {@link #calendarStore}
     * config), and either can be used interchangeably.
     */
<span id='Extensible-calendar-view-AbstractCalendar-cfg-calendarStore'>    /**
</span>     * @cfg {Ext.data.Store} calendarStore
     * The {@link Ext.data.Store store} which is bound to this calendar and contains {@link Extensible.calendar.data.CalendarModel CalendarRecords}.
     * This is an optional store that provides multi-calendar (and multi-color) support. If available an additional field for selecting the
     * calendar in which to save an event will be shown in the edit forms. If this store is not available then all events will simply use
     * the default calendar (and color).
     */
<span id='Extensible-calendar-view-AbstractCalendar-cfg-recurrence'>    /*
</span>     * @cfg {Boolean} recurrence
     * True to show the recurrence field, false to hide it (default). Note that recurrence requires
     * something on the server-side that can parse the iCal RRULE format in order to generate the
     * instances of recurring events to display on the calendar, so this field should only be enabled
     * if the server supports it.
     */
    recurrence: false,

<span id='Extensible-calendar-view-AbstractCalendar-property-recurrenceOptions'>    // @private
</span>    // At the moment these are used, but not required to be modified. In the future, these may be used
    // for customizing how recurrence data is requested and processed.
    recurrenceOptions: {
        expansionMode: &#39;remote&#39;,
        expansionParam: {
            name: &#39;singleEvents&#39;,
            value: true
        }
    },

<span id='Extensible-calendar-view-AbstractCalendar-cfg-readOnly'>    /**
</span>     * @cfg {Boolean} readOnly
     * True to prevent clicks on events or the view from providing CRUD capabilities, false to enable CRUD (the default).
     */
<span id='Extensible-calendar-view-AbstractCalendar-cfg-startDay'>    /**
</span>     * @cfg {Number} startDay
     * The 0-based index for the day on which the calendar week begins (0=Sunday, which is the default)
     */
    startDay: 0,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-spansHavePriority'>    /**
</span>     * @cfg {Boolean} spansHavePriority
     * Allows switching between two different modes of rendering events that span multiple days. When true,
     * span events are always sorted first, possibly at the expense of start dates being out of order (e.g.,
     * a span event that starts at 11am one day and spans into the next day would display before a non-spanning
     * event that starts at 10am, even though they would not be in date order). This can lead to more compact
     * layouts when there are many overlapping events. If false (the default), events will always sort by start date
     * first which can result in a less compact, but chronologically consistent layout.
     */
    spansHavePriority: false,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-trackMouseOver'>    /**
</span>     * @cfg {Boolean} trackMouseOver
     * Whether or not the view tracks and responds to the browser mouseover event on contained elements (defaults to
     * true). If you don&#39;t need mouseover event highlighting you can disable this.
     */
    trackMouseOver: true,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-enableFx'>    /**
</span>     * @cfg {Boolean} enableFx
     * Determines whether or not visual effects for CRUD actions are enabled (defaults to true). If this is false
     * it will override any values for {@link #enableAddFx}, {@link #enableUpdateFx} or {@link enableRemoveFx} and
     * all animations will be disabled.
     */
    enableFx: true,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-enableAddFx'>    /**
</span>     * @cfg {Boolean} enableAddFx
     * True to enable a visual effect on adding a new event (the default), false to disable it. Note that if
     * {@link #enableFx} is false it will override this value. The specific effect that runs is defined in the
     * {@link #doAddFx} method.
     */
    enableAddFx: true,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-enableUpdateFx'>    /**
</span>     * @cfg {Boolean} enableUpdateFx
     * True to enable a visual effect on updating an event, false to disable it (the default). Note that if
     * {@link #enableFx} is false it will override this value. The specific effect that runs is defined in the
     * {@link #doUpdateFx} method.
     */
    enableUpdateFx: false,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-enableRemoveFx'>    /**
</span>     * @cfg {Boolean} enableRemoveFx
     * True to enable a visual effect on removing an event (the default), false to disable it. Note that if
     * {@link #enableFx} is false it will override this value. The specific effect that runs is defined in the
     * {@link #doRemoveFx} method.
     */
    enableRemoveFx: true,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-enableDD'>    /**
</span>     * @cfg {Boolean} enableDD
     * True to enable drag and drop in the calendar view (the default), false to disable it
     */
    enableDD: true,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-enableContextMenus'>    /**
</span>     * @cfg {Boolean} enableContextMenus
     * True to enable automatic right-click context menu handling in the calendar views (the default), false to disable
     * them. Different context menus are provided when clicking on events vs. the view background.
     */
    enableContextMenus: true,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-suppressBrowserContextMenu'>    /**
</span>     * @cfg {Boolean} suppressBrowserContextMenu
     * When {@link #enableContextMenus} is true, the browser context menu will automatically be suppressed whenever a
     * custom context menu is displayed. When this option is true, right-clicks on elements that do not have a custom
     * context menu will also suppress the default browser context menu (no menu will be shown at all). When false,
     * the browser context menu will still show if the right-clicked element has no custom menu (this is the default).
     */
    suppressBrowserContextMenu: false,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-monitorResize'>    /**
</span>     * @cfg {Boolean} monitorResize
     * True to monitor the browser&#39;s resize event (the default), false to ignore it. If the calendar view is rendered
     * into a fixed-size container this can be set to false. However, if the view can change dimensions (e.g., it&#39;s in
     * fit layout in a viewport or some other resizable container) it is very important that this config is true so that
     * any resize event propagates properly to all subcomponents and layouts get recalculated properly.
     */
    monitorResize: true,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-todayText'>    /**
</span>     * @cfg {String} todayText
     * The text to display in the current day&#39;s box in the calendar when {@link #showTodayText} is true (defaults to &#39;Today&#39;)
     */
    todayText: &#39;Today&#39;,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-ddCreateEventText'>    /**
</span>     * @cfg {String} ddCreateEventText
     * The text to display inside the drag proxy while dragging over the calendar to create a new event (defaults to
     * &#39;Create event for {0}&#39; where {0} is a date range supplied by the view)
     */
    ddCreateEventText: &#39;Create event for {0}&#39;,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-ddCopyEventText'>    /**
</span>     * @cfg {String} ddCopyEventText
     * The text to display inside the drag proxy while alt-dragging an event to copy it (defaults to
     * &#39;Copy event to {0}&#39; where {0} is the updated event start date/time supplied by the view)
     */
    ddCopyEventText: &#39;Copy event to {0}&#39;,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-ddMoveEventText'>    /**
</span>     * @cfg {String} ddMoveEventText
     * The text to display inside the drag proxy while dragging an event to reposition it (defaults to
     * &#39;Move event to {0}&#39; where {0} is the updated event start date/time supplied by the view)
     */
    ddMoveEventText: &#39;Move event to {0}&#39;,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-ddResizeEventText'>    /**
</span>     * @cfg {String} ddResizeEventText
     * The string displayed to the user in the drag proxy while dragging the resize handle of an event (defaults to
     * &#39;Update event to {0}&#39; where {0} is the updated event start-end range supplied by the view). Note that
     * this text is only used in views
     * that allow resizing of events.
     */
    ddResizeEventText: &#39;Update event to {0}&#39;,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-defaultEventTitleText'>    /**
</span>     * @cfg {String} defaultEventTitleText
     * The default text to display as the title of an event that has a null or empty string title value (defaults to &#39;(No title)&#39;)
     */
    defaultEventTitleText: &#39;(No title)&#39;,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-dateParamStart'>    /**
</span>     * @cfg {String} dateParamStart
     * The param name representing the start date of the current view range that&#39;s passed in requests to retrieve events
     * when loading the view (defaults to &#39;startDate&#39;).
     */
    dateParamStart: &#39;startDate&#39;,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-dateParamEnd'>    /**
</span>     * @cfg {String} dateParamEnd
     * The param name representing the end date of the current view range that&#39;s passed in requests to retrieve events
     * when loading the view (defaults to &#39;endDate&#39;).
     */
    dateParamEnd: &#39;endDate&#39;,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-dateParamFormat'>    /**
</span>     * @cfg {String} dateParamFormat
     * The format to use for date parameters sent with requests to retrieve events for the calendar (defaults to &#39;Y-m-d&#39;, e.g. &#39;2010-10-31&#39;)
     */
    dateParamFormat: &#39;Y-m-d&#39;,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-editModal'>    /**
</span>     * @cfg {Boolean} editModal
     * True to show the default event editor window modally over the entire page, false to allow user interaction with the page
     * while showing the window (the default). Note that if you replace the default editor window with some alternate component this
     * config will no longer apply.
     */
    editModal: false,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-enableEditDetails'>    /**
</span>     * @cfg {Boolean} enableEditDetails
     * True to show a link on the event edit window to allow switching to the detailed edit form (the default), false to remove the
     * link and disable detailed event editing.
     */
    enableEditDetails: true,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-weekendCls'>    /**
</span>     * @cfg {String} weekendCls
     * A CSS class to apply to weekend days in the current view (defaults to &#39;ext-cal-day-we&#39; which highlights weekend days in light blue).
     * To disable this styling set the value to null or &#39;&#39;.
     */
    weekendCls: &#39;ext-cal-day-we&#39;,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-prevMonthCls'>    /**
</span>     * @cfg {String} prevMonthCls
     * A CSS class to apply to any days that fall in the month previous to the current view&#39;s month (defaults to &#39;ext-cal-day-prev&#39; which
     * highlights previous month days in light gray). To disable this styling set the value to null or &#39;&#39;.
     */
    prevMonthCls: &#39;ext-cal-day-prev&#39;,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-nextMonthCls'>    /**
</span>     * @cfg {String} nextMonthCls
     * A CSS class to apply to any days that fall in the month after the current view&#39;s month (defaults to &#39;ext-cal-day-next&#39; which
     * highlights next month days in light gray). To disable this styling set the value to null or &#39;&#39;.
     */
    nextMonthCls: &#39;ext-cal-day-next&#39;,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-todayCls'>    /**
</span>     * @cfg {String} todayCls
     * A CSS class to apply to the current date when it is visible in the current view (defaults to &#39;ext-cal-day-today&#39; which
     * highlights today in yellow). To disable this styling set the value to null or &#39;&#39;.
     */
    todayCls: &#39;ext-cal-day-today&#39;,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-hideMode'>    /**
</span>     * @cfg {String} hideMode
     * How this component should be hidden. Supported values are &lt;tt&gt;&#39;visibility&#39;&lt;/tt&gt;
     * (css visibility), &lt;tt&gt;&#39;offsets&#39;&lt;/tt&gt; (negative offset position) and &lt;tt&gt;&#39;display&#39;&lt;/tt&gt;
     * (css display).
     *
     * **Note:** For calendar views the default is &#39;offsets&#39; rather than the Ext JS default of
     * &#39;display&#39; in order to preserve scroll position after hiding/showing a scrollable view like Day or Week.
     */
    hideMode: &#39;offsets&#39;,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-notifyOnExceptionTitle'>    /**
</span>     * @cfg {String} notifyOnExceptionTitle
     * @since 1.6.0
     * The notification title used by the {@link #notifyOnException} method when a server error occurs
     * (defaults to &quot;Server Error&quot;).
     */
    notifyOnExceptionTitle: &#39;Server Error&#39;,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-notifyOnExceptionText'>    /**
</span>     * @cfg {String} notifyOnExceptionText
     * @since 1.6.0
     * The notification starting text used by the {@link #notifyOnException} method when a server error occurs
     * (defaults to &quot;The action failed with the following response:&quot;). The text of the error is appended.
     */
    notifyOnExceptionText: &#39;The action failed with the following response:&#39;,
<span id='Extensible-calendar-view-AbstractCalendar-cfg-notifyOnExceptionDefaultMessage'>    /**
</span>     * @cfg {String} notifyOnExceptionDefaultMessage
     * @since 1.6.0
     * The default notification message text used by the {@link #notifyOnException} method when a server error occurs
     * and no error message is returned from the server (defaults to &quot;An unknown error occurred&quot;).
     */
    notifyOnExceptionDefaultMessage: &#39;An unknown error occurred&#39;,

<span id='Extensible-calendar-view-AbstractCalendar-property-ownerCalendarPanel'>    /**
</span>     * @property ownerCalendarPanel
     * @type Extensible.calendar.CalendarPanel
     * If this view is hosted inside a {@link Extensible.calendar.CalendarPanel CalendarPanel} this property will reference
     * it. If the view was created directly outside of a CalendarPanel this property will be null. Read-only.
     */

<span id='Extensible-calendar-view-AbstractCalendar-property-weekCount'>    //private properties -- do not override:
</span>    weekCount: 1,
<span id='Extensible-calendar-view-AbstractCalendar-property-dayCount'>    dayCount: 1,
</span><span id='Extensible-calendar-view-AbstractCalendar-property-eventSelector'>    eventSelector: &#39;.ext-cal-evt&#39;,
</span><span id='Extensible-calendar-view-AbstractCalendar-property-eventSelectorDepth'>    eventSelectorDepth: 10,
</span><span id='Extensible-calendar-view-AbstractCalendar-property-eventOverClass'>    eventOverClass: &#39;ext-evt-over&#39;,
</span><span id='Extensible-calendar-view-AbstractCalendar-property-eventElIdDelimiter'>    eventElIdDelimiter: &#39;-evt-&#39;,
</span><span id='Extensible-calendar-view-AbstractCalendar-property-dayElIdDelimiter'>    dayElIdDelimiter: &#39;-day-&#39;,
</span><span id='Extensible-calendar-view-AbstractCalendar-property-recurringInstanceIdDelimiter'>    recurringInstanceIdDelimiter: &#39;-rid-&#39;,
</span>
<span id='Extensible-calendar-view-AbstractCalendar-method-getEventBodyMarkup'>    /**
</span>     * Returns a string of HTML template markup to be used as the body portion of the event template created
     * by {@link #getEventTemplate}. This provides the flexibility to customize what&#39;s in the body without
     * having to override the entire XTemplate. This string can include any valid {@link Ext.Template} code, and
     * any data tokens accessible to the containing event template can be referenced in this string.
     * @return {String} The body template string
     */
    getEventBodyMarkup: Ext.emptyFn, // must be implemented by a subclass

<span id='Extensible-calendar-view-AbstractCalendar-method-getEventTemplate'>    /**
</span>     * Returns the XTemplate that is bound to the calendar&#39;s event store (it expects records of type
     * {@link Extensible.calendar.data.EventModel}) to populate the calendar views with events. Internally this method
     * by default generates different markup for browsers that support CSS border radius and those that don&#39;t.
     * This method can be overridden as needed to customize the markup generated.
     *
     * Note that this method calls {@link #getEventBodyMarkup} to retrieve the body markup for events separately
     * from the surrounding container markup.  This provides the flexibility to customize what&#39;s in the body without
     * having to override the entire XTemplate. If you do override this method, you should make sure that your
     * overridden version also does the same.
     * @return {Ext.XTemplate} The event XTemplate
     */
    getEventTemplate: Ext.emptyFn, // must be implemented by a subclass

<span id='Extensible-calendar-view-AbstractCalendar-method-getEventClass'>    /**
</span>     * This is undefined by default, but can be implemented to allow custom CSS classes and template data to be
     * conditionally applied to events during rendering. This function will be called with the parameter list shown
     * below and is expected to return the CSS class name (or empty string &#39;&#39; for none) that will be added to the
     * event element&#39;s wrapping div. To apply multiple class names, simply return them space-delimited within the
     * string (e.g., &#39;my-class another-class&#39;). Example usage, applied in a CalendarPanel config:
     *		// This example assumes a custom field of &#39;IsHoliday&#39; has been added to EventRecord
     *		viewConfig: {
     *			getEventClass: function(rec, allday, templateData, store) {
     *				if (rec.data.IsHoliday) {
     *				templateData.iconCls = &#39;holiday&#39;;
     *				return &#39;evt-holiday&#39;;
     *			}
     *			templateData.iconCls = &#39;plain&#39;;
     *			return &#39;&#39;;
     *			},
     *			getEventBodyMarkup: function() {
     *			// This is simplified, but shows the symtax for how you could add a
     *			// custom placeholder that maps back to the templateData property created
     *			// in getEventClass. Note that this is standard Ext template syntax.
     *				if (!this.eventBodyMarkup) {
     *					this.eventBodyMarkup = &#39;&amp;lt;span class=&quot;{iconCls}&quot;&gt;&amp;lt;/span&gt; {Title}&#39;;
     *				}
     *			return this.eventBodyMarkup;
     *			}
     *		}
     * @param {Extensible.calendar.data.EventModel} rec The {@link Extensible.calendar.data.EventModel record} being rendered
     * @param {Boolean} isAllDay A flag indicating whether the event will be *rendered* as an all-day event. Note that this
     * will not necessarily correspond with the value of the &lt;tt&gt;EventRecord.IsAllDay&lt;/tt&gt; field &amp;mdash; events that span multiple
     * days will be rendered using the all-day event template regardless of the field value. If your logic for this function
     * needs to know whether or not the event will be rendered as an all-day event, this value should be used.
     * @param {Object} templateData A plain JavaScript object that is empty by default. You can add custom properties
     * to this object that will then be passed into the event template for the specific event being rendered. If you have
     * overridden the default event template and added custom data placeholders, you can use this object to pass the data
     * into the template that will replace those placeholders.
     * @param {Ext.data.Store} store The Event data store in use by the view
     * @method getEventClass
     * @return {String} A space-delimited CSS class string (or &#39;&#39;)
     */

    initComponent: function() {
        this.setStartDate(this.startDate || new Date());

        this.callParent(arguments);

        if (this.readOnly === true) {
            this.addCls(&#39;ext-cal-readonly&#39;);
        }

        this.addEvents({
<span id='Extensible-calendar-view-AbstractCalendar-event-eventsrendered'>            /**
</span>             * @event eventsrendered
             * Fires after events are finished rendering in the view
             * @param {Extensible.calendar.view.AbstractCalendar} this
             */
            eventsrendered: true,
<span id='Extensible-calendar-view-AbstractCalendar-event-eventclick'>            /**
</span>             * @event eventclick
             * Fires after the user clicks on an event element. This is a cancelable event, so returning false from a
             * handler will cancel the click without displaying the event editor view. This could be useful for
             * validating the rules by which events should be editable by the user.
             * @param {Extensible.calendar.view.AbstractCalendar} this
             * @param {Extensible.calendar.data.EventModel} rec The {@link Extensible.calendar.data.EventModel record} for the event that was clicked on
             * @param {HTMLNode} el The DOM node that was clicked on
             */
            eventclick: true,
<span id='Extensible-calendar-view-AbstractCalendar-event-eventover'>            /**
</span>             * @event eventover
             * Fires anytime the mouse is over an event element
             * @param {Extensible.calendar.view.AbstractCalendar} this
             * @param {Extensible.calendar.data.EventModel} rec The {@link Extensible.calendar.data.EventModel record} for the event that the cursor is over
             * @param {HTMLNode} el The DOM node that is being moused over
             */
            eventover: true,
<span id='Extensible-calendar-view-AbstractCalendar-event-eventout'>            /**
</span>             * @event eventout
             * Fires anytime the mouse exits an event element
             * @param {Extensible.calendar.view.AbstractCalendar} this
             * @param {Extensible.calendar.data.EventModel} rec The {@link Extensible.calendar.data.EventModel record} for the event that the cursor exited
             * @param {HTMLNode} el The DOM node that was exited
             */
            eventout: true,
<span id='Extensible-calendar-view-AbstractCalendar-event-beforedatechange'>            /**
</span>             * @event beforedatechange
             * Fires before the start date of the view changes, giving you an opportunity to save state or anything else you may need
             * to do prior to the UI view changing. This is a cancelable event, so returning false from a handler will cancel both the
             * view change and the setting of the start date.
             * @param {Extensible.calendar.view.AbstractCalendar} this
             * @param {Date} startDate The current start date of the view (as explained in {@link #getStartDate}
             * @param {Date} newStartDate The new start date that will be set when the view changes
             * @param {Date} viewStart The first displayed date in the current view
             * @param {Date} viewEnd The last displayed date in the current view
             */
            beforedatechange: true,
<span id='Extensible-calendar-view-AbstractCalendar-event-datechange'>            /**
</span>             * @event datechange
             * Fires after the start date of the view has changed. If you need to cancel the date change you should handle the
             * {@link #beforedatechange} event and return false from your handler function.
             * @param {Extensible.calendar.view.AbstractCalendar} this
             * @param {Date} startDate The start date of the view (as explained in {@link #getStartDate}
             * @param {Date} viewStart The first displayed date in the view
             * @param {Date} viewEnd The last displayed date in the view
             */
            datechange: true,
<span id='Extensible-calendar-view-AbstractCalendar-event-rangeselect'>            /**
</span>             * @event rangeselect
             * Fires after the user drags on the calendar to select a range of dates/times in which to create an event. This is a
             * cancelable event, so returning false from a handler will cancel the drag operation and clean up any drag shim elements
             * without displaying the event editor view. This could be useful for validating that a user can only create events within
             * a certain range.
             * @param {Extensible.calendar.view.AbstractCalendar} this
             * @param {Object} dates An object containing the start (StartDate property) and end (EndDate property) dates selected
             * @param {Function} callback A callback function that MUST be called after the event handling is complete so that
             * the view is properly cleaned up (shim elements are persisted in the view while the user is prompted to handle the
             * range selection). The callback is already created in the proper scope, so it simply needs to be executed as a standard
             * function call (e.g., callback()).
             */
            rangeselect: true,
<span id='Extensible-calendar-view-AbstractCalendar-event-beforeeventcopy'>            /**
</span>             * @event beforeeventcopy
             * Fires before an existing event is duplicated by the user via the &quot;copy&quot; command. This is a
             * cancelable event, so returning false from a handler will cancel the copy operation.
             * @param {Extensible.calendar.view.AbstractCalendar} this
             * @param {Extensible.calendar.data.EventModel} rec The {@link Extensible.calendar.data.EventModel
             * record} for the event that will be copied
             * @param {Date} dt The new start date to be set in the copy (the end date will be automaticaly
             * adjusted to match the original event duration)
             */
            beforeeventcopy: true,
<span id='Extensible-calendar-view-AbstractCalendar-event-eventcopy'>            /**
</span>             * @event eventcopy
             * Fires after an event has been duplicated by the user via the &quot;copy&quot; command. If you need to
             * cancel the copy operation you should handle the {@link #beforeeventcopy} event and return
             * false from your handler function.
             * @param {Extensible.calendar.view.AbstractCalendar} this
             * @param {Extensible.calendar.data.EventModel} rec The {@link Extensible.calendar.data.EventModel
             * record} for the event that was copied (with updated start and end dates)
             */
            eventcopy: true,
<span id='Extensible-calendar-view-AbstractCalendar-event-beforeeventmove'>            /**
</span>             * @event beforeeventmove
             * Fires after an event element has been dragged by the user and dropped in a new position, but before
             * the event record is updated with the new dates, providing a hook for canceling the update.
             * To cancel the move, return false from a handling function. This could be useful for validating
             * that a user can only move events within a certain date range, for example.
             * @param {Extensible.calendar.view.AbstractCalendar} this
             * @param {Extensible.calendar.data.EventModel} rec The {@link Extensible.calendar.data.EventModel record}
             * for the event that will be moved. Start and end dates will be the original values before the move started.
             * @param {Date} dt The new start date to be set (the end date will be automaticaly calculated to match
             * based on the event duration)
             */
            beforeeventmove: true,
<span id='Extensible-calendar-view-AbstractCalendar-event-eventmove'>            /**
</span>             * @event eventmove
             * Fires after an event element has been moved to a new position and its data updated. If you need to
             * cancel the move operation you should handle the {@link #beforeeventmove} event and return false
             * from your handler function.
             * @param {Extensible.calendar.view.AbstractCalendar} this
             * @param {Extensible.calendar.data.EventModel} rec The {@link Extensible.calendar.data.EventModel record}
             * for the event that was moved with updated start and end dates
             */
            eventmove: true,
<span id='Extensible-calendar-view-AbstractCalendar-event-initdrag'>            /**
</span>             * @event initdrag
             * Fires when a drag operation is initiated in the view
             * @param {Extensible.calendar.view.AbstractCalendar} this
             */
            initdrag: true,
<span id='Extensible-calendar-view-AbstractCalendar-event-dayover'>            /**
</span>             * @event dayover
             * Fires while the mouse is over a day element
             * @param {Extensible.calendar.view.AbstractCalendar} this
             * @param {Date} dt The date that is being moused over
             * @param {Ext.Element} el The day Element that is being moused over
             */
            dayover: true,
<span id='Extensible-calendar-view-AbstractCalendar-event-dayout'>            /**
</span>             * @event dayout
             * Fires when the mouse exits a day element
             * @param {Extensible.calendar.view.AbstractCalendar} this
             * @param {Date} dt The date that is exited
             * @param {Ext.Element} el The day Element that is exited
             */
            dayout: true,
<span id='Extensible-calendar-view-AbstractCalendar-event-editdetails'>            /**
</span>             * @event editdetails
             * Fires when the user selects the option in this window to continue editing in the detailed edit form
             * (by default, an instance of {@link Extensible.calendar.form.EventDetails}. Handling code should hide this window
             * and transfer the current event record to the appropriate instance of the detailed form by showing it
             * and calling {@link Extensible.calendar.form.EventDetails#loadRecord loadRecord}.
             * @param {Extensible.calendar.view.AbstractCalendar} this
             * @param {Extensible.calendar.data.EventModel} rec The {@link Extensible.calendar.data.EventModel record} that is currently being edited
             * @param {Ext.Element} el The target element
             */
            editdetails: true,
<span id='Extensible-calendar-view-AbstractCalendar-event-eventadd'>            /**
</span>             * @event eventadd
             * Fires after a new event has been added to the underlying store
             * @param {Extensible.calendar.view.AbstractCalendar} this
             * @param {Extensible.calendar.data.EventModel} rec The new {@link Extensible.calendar.data.EventModel record} that was added
             */
            eventadd: true,
<span id='Extensible-calendar-view-AbstractCalendar-event-eventupdate'>            /**
</span>             * @event eventupdate
             * Fires after an existing event has been updated
             * @param {Extensible.calendar.view.AbstractCalendar} this
             * @param {Extensible.calendar.data.EventModel} rec The new {@link Extensible.calendar.data.EventModel record} that was updated
             */
            eventupdate: true,
<span id='Extensible-calendar-view-AbstractCalendar-event-eventcancel'>            /**
</span>             * @event eventcancel
             * Fires after an event add/edit operation has been canceled by the user and no store update took place
             * @param {Extensible.calendar.view.AbstractCalendar} this
             * @param {Extensible.calendar.data.EventModel} rec The new {@link Extensible.calendar.data.EventModel record} that was canceled
             */
            eventcancel: true,
<span id='Extensible-calendar-view-AbstractCalendar-event-beforeeventdelete'>            /**
</span>             * @event beforeeventdelete
             * Fires before an event is deleted by the user. This is a cancelable event, so returning false from a handler
             * will cancel the delete operation.
             * @param {Extensible.calendar.view.AbstractCalendar} this
             * @param {Extensible.calendar.data.EventModel} rec The {@link Extensible.calendar.data.EventModel record} for the event that was deleted
             * @param {Ext.Element} el The target element
             */
            beforeeventdelete: true,
<span id='Extensible-calendar-view-AbstractCalendar-event-eventdelete'>            /**
</span>             * @event eventdelete
             * Fires after an event has been deleted by the user. If you need to cancel the delete operation you should handle the
             * {@link #beforeeventdelete} event and return false from your handler function.
             * @param {Extensible.calendar.view.AbstractCalendar} this
             * @param {Extensible.calendar.data.EventModel} rec The {@link Extensible.calendar.data.EventModel record} for the event that was deleted
             * @param {Ext.Element} el The target element
             */
            eventdelete: true,
<span id='Extensible-calendar-view-AbstractCalendar-event-eventexception'>            /**
</span>             * @event eventexception
             * Fires after an event has been processed via an Ext proxy and returned with an exception. This
             * could be because of a server error, or because the data returned &lt;tt&gt;success: false&lt;/tt&gt;.
             *
             * The view provides default handling via the overrideable {@link #notifyOnException} method. If
             * any function handling this event returns false, the notifyOnException method will not be called.
             *
             * Note that only Server proxy and subclasses (including Ajax proxy) will raise this event.
             *
             * @param {Extensible.calendar.view.AbstractCalendar} this
             * @param {Object} response The raw response object returned from the server
             * @param {Ext.data.Operation} operation The operation that was processed
             * @since 1.6.0
             */
            eventexception: true
        });
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-afterRender'>    afterRender: function() {
</span>        this.callParent(arguments);

        this.renderTemplate();

        if (this.store) {
            this.setStore(this.store, true);
            if (this.store.deferLoad) {
                this.reloadStore(this.store.deferLoad);
                delete this.store.deferLoad;
            }
            else {
                this.store.initialParams = this.getStoreParams();
            }
        }
        if (this.calendarStore) {
            this.setCalendarStore(this.calendarStore, true);
        }

        this.on(&#39;resize&#39;, this.onResize, this);

        this.el.on({
            &#39;mouseover&#39;: this.onMouseOver,
            &#39;mouseout&#39;: this.onMouseOut,
            &#39;click&#39;: this.onClick,
            //&#39;resize&#39;: this.onResize,
            scope: this
        });

        // currently the context menu only contains CRUD actions so do not show it if read-only
        if (this.enableContextMenus &amp;&amp; this.readOnly !== true) {
            this.el.on(&#39;contextmenu&#39;, this.onContextMenu, this);
        }

        this.el.unselectable();

        if (this.enableDD &amp;&amp; this.readOnly !== true &amp;&amp; this.initDD) {
            this.initDD();
        }

        this.on(&#39;eventsrendered&#39;, this.onEventsRendered);

        Ext.defer(this.forceSize, 100, this);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-getStoreDateParams'>    /**
</span>     * Returns an object containing the start and end dates to be passed as params in all calls
     * to load the event store. The param names are customizable using {@link #dateParamStart}
     * and {@link #dateParamEnd} and the date format used in requests is defined by {@link #dateParamFormat}.
     * If you need to add additional parameters to be sent when loading the store see {@link #getStoreParams}.
     * @return {Object} An object containing the start and end dates
     */
    getStoreDateParams: function() {
        var o = {};
        o[this.dateParamStart] = Ext.Date.format(this.viewStart, this.dateParamFormat);
        o[this.dateParamEnd] = Ext.Date.format(this.viewEnd, this.dateParamFormat);
        return o;
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-getStoreParams'>    /**
</span>     * Returns an object containing all key/value params to be passed when loading the event store.
     * By default the returned object will simply be the same object returned by {@link #getStoreDateParams},
     * but this method is intended to be overridden if you need to pass anything in addition to start and end dates.
     * See the inline code comments when overriding for details.
     * @return {Object} An object containing all params to be sent when loading the event store
     */
    getStoreParams: function() {
        // This is needed if you require the default start and end dates to be included
        var params = this.getStoreDateParams();

        // Here is where you can add additional custom params, e.g.:
        // params.now = Ext.Date.format(new Date(), this.dateParamFormat);
        // params.foo = &#39;bar&#39;;
        // params.number = 123;

        return params;
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-reloadStore'>    /**
</span>     * Reloads the view&#39;s underlying event store using the params returned from {@link #getStoreParams}.
     * Reloading the store is typically managed automatically by the view itself, but the method is
     * available in case a manual reload is ever needed.
     * @param {Object} options (optional) An object matching the format used by Store&#39;s {@link Ext.data.Store#load load} method
     */
    reloadStore: function(o) {
        Extensible.log(&#39;reloadStore&#39;);

        var recurrenceOptions = this.recurrenceOptions;

        o = Ext.isObject(o) ? o : {};
        o.params = o.params || {};

        Ext.apply(o.params, this.getStoreParams());

        if (this.recurrence &amp;&amp; recurrenceOptions.expansionParam &amp;&amp; recurrenceOptions.expansionMode === &#39;remote&#39;) {
            o.params[recurrenceOptions.expansionParam.name] = recurrenceOptions.expansionParam.value;
        }

        this.store.load(o);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-onEventsRendered'>    onEventsRendered: function() {
</span>        this.forceSize();
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-forceSize'>    forceSize: function() {
</span>        var el = this.el;

        if (el &amp;&amp; el.down) {
            var hd = el.down(&#39;.ext-cal-hd-ct&#39;),
                bd = el.down(&#39;.ext-cal-body-ct&#39;);

            if (!bd || !hd) {
                return;
            }

            var headerHeight = hd.getHeight(),
                sz = el.parent().getSize();

            bd.setHeight(sz.height - headerHeight);
        }
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-refresh'>    /**
</span>     * Refresh the current view, optionally reloading the event store also. While this is normally
     * managed internally on any navigation and/or CRUD action, there are times when you might want
     * to refresh the view manually (e.g., if you&#39;d like to reload using different {@link #getStoreParams params}).
     * @param {Boolean} reloadData True to reload the store data first, false to simply redraw the view using current
     * data (defaults to false)
     */
    refresh: function(reloadData) {
        if (!this.isActiveView()) {
            Extensible.log(&#39;refresh (AbstractCalendar), skipped for non-active view (&#39; + this.id + &#39;)&#39;);
            return;
        }
        Extensible.log(&#39;refresh (AbstractCalendar), reload = &#39; + reloadData);

        if (reloadData === true) {
            this.reloadStore();
        }
        else {
            this.prepareData();
            this.renderTemplate();
            this.renderItems();
        }
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-getWeekCount'>    getWeekCount: function() {
</span>        var days = Extensible.Date.diffDays(this.viewStart, this.viewEnd);
        return Math.ceil(days / this.dayCount);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-prepareData'>    prepareData: function() {
</span>        var lastInMonth = Ext.Date.getLastDateOfMonth(this.startDate),
            w = 0,
            d = 0,
            row = 0,
            currentDt = Extensible.Date.add(Ext.Date.clearTime(this.viewStart, true), {hours: 12}),
            weeks = this.weekCount &lt; 1 ? 6 : this.weekCount;

        lastInMonth = Extensible.Date.add(Ext.Date.clearTime(lastInMonth), {hours: 12})

        this.eventGrid = [[]];
        this.allDayGrid = [[]];
        this.evtMaxCount = [];

        var evtsInView = this.store.queryBy(function(rec) {
            return this.isEventVisible(rec.data);
        }, this);

        var evtsInDay = function(rec) {
            var EventMappings = Extensible.calendar.data.EventMappings,
                startDt = Extensible.Date.add(Ext.Date.clearTime(rec.data[EventMappings.StartDate.name], true), {hours: 12}),
                startsOnDate = Extensible.Date.diffDays(currentDt, startDt) === 0,
                spansFromPrevView = (w === 0 &amp;&amp; d === 0 &amp;&amp; (currentDt &gt; startDt));

            return startsOnDate || spansFromPrevView;
        };

        for (; w &lt; weeks; w++) {
            this.evtMaxCount[w] = this.evtMaxCount[w] || 0;

            if (this.weekCount === -1 &amp;&amp; currentDt &gt; lastInMonth) {
                //current week is fully in next month so skip
                break;
            }
            this.eventGrid[w] = this.eventGrid[w] || [];
            this.allDayGrid[w] = this.allDayGrid[w] || [];

            for (d = 0; d &lt; this.dayCount; d++) {
                if (evtsInView.getCount() &gt; 0) {
                    var evts = evtsInView.filterBy(evtsInDay, this);
                    this.sortEventRecordsForDay(evts);
                    this.prepareEventGrid(evts, w, d);
                }
                currentDt = Extensible.Date.add(currentDt, {days: 1});
            }
        }
        this.currentWeekCount = w;
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-prepareEventGrid'>    prepareEventGrid: function(evts, w, d) {
</span>        var me = this,
            row = 0,
            maxEventsForDay;

        evts.each(function(evt) {
            var M = Extensible.calendar.data.EventMappings;

            if (Extensible.Date.diffDays(evt.data[M.StartDate.name], evt.data[M.EndDate.name]) &gt; 0) {
                var daysInView = Extensible.Date.diffDays(
                    Extensible.Date.max(me.viewStart, evt.data[M.StartDate.name]),
                    Extensible.Date.min(me.viewEnd, evt.data[M.EndDate.name])) + 1;

                me.prepareEventGridSpans(evt, me.eventGrid, w, d, daysInView);
                me.prepareEventGridSpans(evt, me.allDayGrid, w, d, daysInView, true);
            }
            else {
                row = me.findEmptyRowIndex(w,d);
                me.eventGrid[w][d] = me.eventGrid[w][d] || [];
                me.eventGrid[w][d][row] = evt;

                if (evt.data[M.IsAllDay.name]) {
                    row = me.findEmptyRowIndex(w,d, true);
                    me.allDayGrid[w][d] = me.allDayGrid[w][d] || [];
                    me.allDayGrid[w][d][row] = evt;
                }
            }

            me.setMaxEventsForDay(w, d);

            return true;
        }, me);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-setMaxEventsForDay'>    setMaxEventsForDay: function(weekIndex, dayIndex) {
</span>        var max = (this.maxEventsPerDay + 1) || 999;

        // If calculating the max event count for the day/week view header, use the allDayGrid
        // so that only all-day events displayed in that area get counted, otherwise count all events.
        var maxEventsForDay = this[this.isHeaderView ? &#39;allDayGrid&#39; : &#39;eventGrid&#39;][weekIndex][dayIndex] || [];

        this.evtMaxCount[weekIndex] = this.evtMaxCount[weekIndex] || 0;

        if (maxEventsForDay.length &amp;&amp; this.evtMaxCount[weekIndex] &lt; maxEventsForDay.length) {
            this.evtMaxCount[weekIndex] = Math.min(max, maxEventsForDay.length);
        }
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-prepareEventGridSpans'>    prepareEventGridSpans: function(evt, grid, w, d, days, allday) {
</span>        // this event spans multiple days/weeks, so we have to preprocess
        // the events and store special span events as placeholders so that
        // the render routine can build the necessary TD spans correctly.
        var w1 = w,
            d1 = d,
            row = this.findEmptyRowIndex(w,d,allday),
            dt = Extensible.Date.add(Ext.Date.clearTime(this.viewStart, true), {hours: 12});

        var start = {
            event: evt,
            isSpan: true,
            isSpanStart: true,
            spanLeft: false,
            spanRight: (d === 6)
        };

        grid[w][d] = grid[w][d] || [];
        grid[w][d][row] = start;

        this.setMaxEventsForDay(w, d);

        while (--days) {
            dt = Extensible.Date.add(dt, {days: 1});

            if (dt &gt; this.viewEnd) {
                break;
            }
            if (++d1 &gt; 6) {
                // reset counters to the next week
                d1 = 0; w1++;
                row = this.findEmptyRowIndex(w1,0);
            }
            grid[w1] = grid[w1] || [];
            grid[w1][d1] = grid[w1][d1] || [];

            grid[w1][d1][row] = {
                event: evt,
                isSpan: true,
                isSpanStart: (d1 === 0),
                spanLeft: (w1 &gt; w) &amp;&amp; (d1 % 7 === 0),
                spanRight: (d1 === 6) &amp;&amp; (days &gt; 1)
            };

            // In this loop we are pre-processing empty span placeholders. In the case
            // where a given week might only contain such spans, we have to make this
            // max event check on each iteration to make sure that our empty placeholder
            // divs get created correctly even without &quot;real&quot; events:
            this.setMaxEventsForDay(w1, d1);
        }
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-findEmptyRowIndex'>    findEmptyRowIndex: function(w, d, allday) {
</span>        var grid = allday ? this.allDayGrid : this.eventGrid,
            day = grid[w] ? grid[w][d] || [] : [],
            i = 0,
            len = day.length;

        for (; i &lt; len; i++) {
            if (!day[i]) {
                return i;
            }
        }
        return len;
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-renderTemplate'>    renderTemplate: function() {
</span>        if (this.tpl) {
            this.tpl.overwrite(this.el, this.getTemplateParams());
            this.lastRenderStart = Ext.Date.clone(this.viewStart);
            this.lastRenderEnd = Ext.Date.clone(this.viewEnd);
        }
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-getTemplateParams'>    getTemplateParams: function() {
</span>        return {
            viewStart: this.viewStart,
            viewEnd: this.viewEnd,
            startDate: this.startDate,
            dayCount: this.dayCount,
            weekCount: this.weekCount,
            weekendCls: this.weekendCls,
            prevMonthCls: this.prevMonthCls,
            nextMonthCls: this.nextMonthCls,
            todayCls: this.todayCls
        };
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-disableStoreEvents'>    /**
</span>     * Disable store event monitoring within this view. Note that if you do this the view will no longer
     * refresh itself automatically when CRUD actions occur. To enable store events see {@link #enableStoreEvents}.
     * @return {CalendarView} this
     */
    disableStoreEvents: function() {
        this.monitorStoreEvents = false;
        return this;
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-enableStoreEvents'>    /**
</span>     * Enable store event monitoring within this view if disabled by {@link #disbleStoreEvents}.
     * @return {CalendarView} this
     */
    enableStoreEvents: function(refresh) {
        this.monitorStoreEvents = true;
        if (refresh === true) {
            this.refresh();
        }
        return this;
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-onResize'>    onResize: function() {
</span>        this.refresh(false);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-onInitDrag'>    onInitDrag: function() {
</span>        this.fireEvent(&#39;initdrag&#39;, this);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-onEventDrop'>    onEventDrop: function(rec, dt, mode) {
</span>        this[(mode || &#39;move&#39;) + &#39;Event&#39;](rec, dt);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-onCalendarEndDrag'>    onCalendarEndDrag: function(start, end, onComplete) {
</span>        // set this flag for other event handlers that might conflict while we&#39;re waiting
        this.dragPending = true;

        var dates = {},
            boundOnComplete = Ext.bind(this.onCalendarEndDragComplete, this, [onComplete]);

        dates[Extensible.calendar.data.EventMappings.StartDate.name] = start;
        dates[Extensible.calendar.data.EventMappings.EndDate.name] = end;

        if (this.fireEvent(&#39;rangeselect&#39;, this, dates, boundOnComplete) !== false) {
            this.showEventEditor(dates, null);

            if (this.editWin) {
                this.editWin.on(&#39;hide&#39;, boundOnComplete, this, {single:true});
            }
            else {
                boundOnComplete();
            }
        }
        else {
            // client code canceled the selection so clean up immediately
            this.onCalendarEndDragComplete(boundOnComplete);
        }
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-onCalendarEndDragComplete'>    onCalendarEndDragComplete: function(onComplete) {
</span>        // callback for the drop zone to clean up
        onComplete();
        // clear flag for other events to resume normally
        this.dragPending = false;
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-refreshAfterEventChange'>    /**
</span>     * Refresh the view. Determine if a store reload is required after a given CRUD operation.
     * @param {String} action One of &#39;create&#39;, &#39;update&#39; or &#39;delete&#39;
     * @param {Ext.data.Operation} operation The affected operation
     */
    refreshAfterEventChange: function(action, operation) {
        // Determine if a store reload is needed. A store reload is needed if the event is recurring after being
        // edited or was recurring before being edited AND an event store reload has not been triggered already for
        // this operation. If an event is not currently recurring (isRecurring = false) but still has an instance
        // start date set, then it must have been recurring and edited to no longer recur.
        var RInstanceStartDate = Extensible.calendar.data.EventMappings.RInstanceStartDate,
            isInstance = RInstanceStartDate &amp;&amp; !!operation.records[0].get(RInstanceStartDate.name),
            reload = (operation.records[0].isRecurring() || isInstance) &amp;&amp; !operation.wasStoreReloadTriggered;

        if (reload) {
            // For calendar views with a body and a header component (e.g. weekly view, day view), this function is
            // called twice. Ensure that a store reload is triggered only once for the same operation.
            operation.wasStoreReloadTriggered = true;
        }
        this.refresh(reload);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-onUpdate'>    onUpdate: function(store, operation, updateType) {
</span>        if (this.hidden === true || this.ownerCt.hidden === true || this.monitorStoreEvents === false) {
            // Hidden calendar view don&#39;t need to be refreshed. For views composed of header and body (for example
            // Extensible.calendar.view.Day or Extensible.calendar.view.Week) we need to check the ownerCt to find out
            // if a view is hidden.
            return;
        }
        if (updateType === Ext.data.Record.COMMIT) {
            Extensible.log(&#39;onUpdate&#39;);
            this.dismissEventEditor();

            this.refreshAfterEventChange(&#39;update&#39;, operation);

            var rec = operation.records[0];

            if (this.enableFx &amp;&amp; this.enableUpdateFx) {
                this.doUpdateFx(this.getEventEls(rec.data[Extensible.calendar.data.EventMappings.EventId.name]), {
                    scope: this
                });
            }
        }
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-doUpdateFx'>    /**
</span>     * Provides the element effect(s) to run after an event is updated. The method is passed a {@link Ext.CompositeElement}
     * that contains one or more elements in the DOM representing the event that was updated. The default
     * effect is {@link Ext.Element#highlight highlight}. Note that this method will only be called when
     * {@link #enableUpdateFx} is true (it is false by default).
     * @param {Ext.CompositeElement} el The {@link Ext.CompositeElement} representing the updated event
     * @param {Object} options An options object to be passed through to any Element.Fx methods. By default this
     * object only contains the current scope (&lt;tt&gt;{scope:this}&lt;/tt&gt;) but you can also add any additional fx-specific
     * options that might be needed for a particular effect to this object.
     */
    doUpdateFx: function(els, o) {
        this.highlightEvent(els, null, o);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-onAdd'>    onAdd: function(store, operation) {
</span>        var rec = operation.records[0];

        if (this.hidden === true || this.ownerCt.hidden === true || this.monitorStoreEvents === false) {
            // Hidden calendar view don&#39;t need to be refreshed. For views composed of header and body (for example
            // Extensible.calendar.view.Day or Extensible.calendar.view.Week) we need to check the ownerCt to find out
            // if a view is hidden.
            return;
        }
        // if (rec._deleting) {
            // delete rec._deleting;
            // return;
        // }

        Extensible.log(&#39;onAdd&#39;);

        this.dismissEventEditor();
        //this.tempEventId = rec.id;

        this.refreshAfterEventChange(&#39;create&#39;, operation);

        // if (this.enableFx &amp;&amp; this.enableAddFx) {
            // this.doAddFx(this.getEventEls(rec.data[Extensible.calendar.data.EventMappings.EventId.name]), {
                // scope: this
            // });
        // }
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-doAddFx'>    /**
</span>     * Provides the element effect(s) to run after an event is added. The method is passed a {@link Ext.CompositeElement}
     * that contains one or more elements in the DOM representing the event that was added. The default
     * effect is {@link Ext.Element#fadeIn fadeIn}. Note that this method will only be called when
     * {@link #enableAddFx} is true (it is true by default).
     * @param {Ext.CompositeElement} el The {@link Ext.CompositeElement} representing the added event
     * @param {Object} options An options object to be passed through to any Element.Fx methods. By default this
     * object only contains the current scope (&lt;tt&gt;{scope:this}&lt;/tt&gt;) but you can also add any additional fx-specific
     * options that might be needed for a particular effect to this object.
     */
    doAddFx: function(els, o) {
        els.fadeIn(Ext.apply(o, { duration: 2000 }));
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-onRemove'>    onRemove: function(store, operation) {
</span>        if (this.hidden === true || this.ownerCt.hidden === true || this.monitorStoreEvents === false) {
            // Hidden calendar view don&#39;t need to be refreshed. For views composed of header and body (for example
            // Extensible.calendar.view.Day or Extensible.calendar.view.Week) we need to check the ownerCt to find out
            // if a view is hidden.
            return;
        }

        Extensible.log(&#39;onRemove&#39;);
        this.dismissEventEditor();

        var rec = operation.records[0];

        if (this.enableFx &amp;&amp; this.enableRemoveFx) {
            this.doRemoveFx(this.getEventEls(rec.data[Extensible.calendar.data.EventMappings.EventId.name]), {
                remove: true,
                scope: this,
                callback: Ext.bind(this.refreshAfterEventChange, this, [&#39;delete&#39;, operation])
            });
        }
        else {
            this.getEventEls(rec.data[Extensible.calendar.data.EventMappings.EventId.name]).remove();
            this.refreshAfterEventChange(&#39;delete&#39;, operation);
        }
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-doRemoveFx'>    /**
</span>     * Provides the element effect(s) to run after an event is removed. The method is passed a {@link Ext.CompositeElement}
     * that contains one or more elements in the DOM representing the event that was removed. The default
     * effect is {@link Ext.Element#fadeOut fadeOut}. Note that this method will only be called when
     * {@link #enableRemoveFx} is true (it is true by default).
     * @param {Ext.CompositeElement} el The {@link Ext.CompositeElement} representing the removed event
     * @param {Object} options An options object to be passed through to any Element.Fx methods. By default this
     * object contains the following properties:
     *		{
     *			remove: true, // required by fadeOut to actually remove the element(s)
     *			scope: this,  // required for the callback
     *			callback: fn  // required to refresh the view after the fx finish
     *		}
     * While you can modify this options object as needed if you change the effect used, please note that the
     * callback method (and scope) MUST still be passed in order for the view to refresh correctly after the removal.
     * Please see the inline code comments before overriding this method.
     */
    doRemoveFx: function(els, o) {
        // Please make sure you keep this entire code block or removing events might not work correctly!
        // Removing is a little different because we have to wait for the fx to finish, then we have to actually
        // refresh the view AFTER the fx are run (this is different than add and update).
        if (els.getCount() === 0 &amp;&amp; Ext.isFunction(o.callback)) {
            // if there are no matching elements in the view make sure the callback still runs.
            // this can happen when an event accessed from the &quot;more&quot; popup is deleted.
            o.callback.call(o.scope || this);
        }
        else {
            // If you&#39;d like to customize the remove fx do so here. Just make sure you
            // DO NOT override the default callback property on the options object, and that
            // you still pass that object in whatever fx method you choose.
            els.fadeOut(o);
        }
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-highlightEvent'>    /**
</span>     * Visually highlights an event using {@link Ext.Fx#highlight} config options.
     * @param {Ext.CompositeElement} els The element(s) to highlight
     * @param {Object} color (optional) The highlight color. Should be a 6 char hex
     * color without the leading # (defaults to yellow: &#39;ffff9c&#39;)
     * @param {Object} o (optional) Object literal with any of the {@link Ext.Fx} config
     * options. See {@link Ext.Fx#highlight} for usage examples.
     */
    highlightEvent: function(els, color, o) {
        if (this.enableFx) {
            if (Ext.isIE || Ext.isOpera) {
                // Fun IE/Opera handling:
                var highlightEl;

                els.each(function(el) {
                    el.highlight(color, Ext.applyif ({attr:&#39;color&#39;}, o));
                    var highlightEl = el.down(&#39;.ext-cal-evm&#39;);

                    if (highlightEl) {
                        highlightEl.highlight(color, o);
                    }
                }, this);
            }
            else {
                els.highlight(color, o);
            }
        }
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-getEventIdFromEl'>    /**
</span>     * Retrieve an Event object&#39;s id from its corresponding node in the DOM.
     * @param {String/Element/HTMLElement} el An {@link Ext.Element}, DOM node or id
     */
    getEventIdFromEl: function(el) {
        el = Ext.get(el);
        var parts, id = &#39;&#39;, cls, classes = el.dom.className.split(&#39; &#39;);

        Ext.each(classes, function(cls) {
            parts = cls.split(this.eventElIdDelimiter);
            if (parts.length &gt; 1) {
                id = parts[1];
                return false;
            }
        }, this);

        return id;
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-getEventId'>    getEventId: function(eventId) {
</span>        if (eventId === undefined &amp;&amp; this.tempEventId) {
            // temp record id assigned during an add, will be overwritten later
            eventId = this.tempEventId;
        }
        return eventId;
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-getEventSelectorCls'>    /**
</span>     *
     * @param {String} eventId
     * @param {Boolean} forSelect
     * @return {String} The selector class
     */
    getEventSelectorCls: function(eventId, forSelect) {
        var prefix = forSelect ? &#39;.&#39; : &#39;&#39;,
            id = this.getEventId(eventId),
            cls = prefix + this.id + this.eventElIdDelimiter + id;

        return cls;
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-getEventEls'>    /**
</span>     *
     * @param {String} eventId
     * @return {Ext.dom.CompositeElement} The matching CompositeElement of nodes
     * that comprise the rendered event.  Any event that spans across a view
     * boundary will contain more than one internal Element.
     */
    getEventEls: function(eventId) {
        var els = this.el.select(this.getEventSelectorCls(this.getEventId(eventId), true), false);
        return Ext.create(&#39;Ext.CompositeElement&#39;, els);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-isToday'>    /**
</span>     * Returns true if the view is currently displaying today&#39;s date, else false.
     * @return {Boolean} True or false
     */
    isToday: function() {
        var today = Ext.Date.clearTime(new Date()).getTime();
        return this.viewStart.getTime() &lt;= today &amp;&amp; this.viewEnd.getTime() &gt;= today;
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-isEventVisible'>    isEventVisible: function(evt) {
</span>        var eventMappings = Extensible.calendar.data.EventMappings,
            calendarMappings = Extensible.calendar.data.CalendarMappings,
            data = evt.data || evt,
            calRec = this.calendarStore ? this.calendarStore.findRecord(calendarMappings.CalendarId.name,
                evt[eventMappings.CalendarId.name]) : null;

        if (calRec &amp;&amp; calRec.data[calendarMappings.IsHidden.name] === true) {
            // if the event is on a hidden calendar then no need to test the date boundaries
            return false;
        }

        var start = this.viewStart.getTime(),
            end = this.viewEnd.getTime(),
            evStart = data[eventMappings.StartDate.name].getTime(),
            evEnd = data[eventMappings.EndDate.name].getTime(),
            isOverlapping = Extensible.Date.rangesOverlap(start, end, evStart, evEnd);

        return isOverlapping;
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-isOverlapping'>    isOverlapping: function(evt1, evt2) {
</span>        var ev1 = evt1.data ? evt1.data : evt1,
            ev2 = evt2.data ? evt2.data : evt2,
            M = Extensible.calendar.data.EventMappings,
            start1 = ev1[M.StartDate.name].getTime(),
            end1 = Extensible.Date.add(ev1[M.EndDate.name], {seconds: -1}).getTime(),
            start2 = ev2[M.StartDate.name].getTime(),
            end2 = Extensible.Date.add(ev2[M.EndDate.name], {seconds: -1}).getTime(),
            startDiff = Extensible.Date.diff(ev1[M.StartDate.name], ev2[M.StartDate.name], &#39;m&#39;);

            if (end1&lt;start1) {
                end1 = start1;
            }
            if (end2&lt;start2) {
                end2 = start2;
            }

//            var ev1startsInEv2 = (start1 &gt;= start2 &amp;&amp; start1 &lt;= end2),
//            ev1EndsInEv2 = (end1 &gt;= start2 &amp;&amp; end1 &lt;= end2),
//            ev1SpansEv2 = (start1 &lt; start2 &amp;&amp; end1 &gt; end2),
            var evtsOverlap = Extensible.Date.rangesOverlap(start1, end1, start2, end2),
                minimumMinutes = this.minEventDisplayMinutes || 0, // applies in day/week body view only for vertical overlap
                ev1MinHeightOverlapsEv2 = minimumMinutes &gt; 0 &amp;&amp; (startDiff &gt; -minimumMinutes &amp;&amp; startDiff &lt; minimumMinutes);

        //return (ev1startsInEv2 || ev1EndsInEv2 || ev1SpansEv2 || ev1MinHeightOverlapsEv2);
        return (evtsOverlap || ev1MinHeightOverlapsEv2);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-isEventSpanning'>    isEventSpanning: function(evt) {
</span>        var M = Extensible.calendar.data.EventMappings,
            data = evt.data || evt,
            diff;

        diff = Extensible.Date.diffDays(data[M.StartDate.name], data[M.EndDate.name]);

        //TODO: Prevent 00:00 end time from causing a span. This logic is OK, but
        //      other changes are still needed for it to work fully. Deferring for now.
//        if (diff &lt;= 1 &amp;&amp; Extensible.Date.isMidnight(data[M.EndDate.name])) {
//            return false;
//        }
        return diff &gt; 0;
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-getDayEl'>    getDayEl: function(dt) {
</span>        return Ext.get(this.getDayId(dt));
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-getDayId'>    getDayId: function(dt) {
</span>        if (Ext.isDate(dt)) {
            dt = Ext.Date.format(dt, &#39;Ymd&#39;);
        }
        return this.id + this.dayElIdDelimiter + dt;
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-getStartDate'>    /**
</span>     * Returns the start date of the view, as set by {@link #setStartDate}. Note that this may not
     * be the first date displayed in the rendered calendar -- to get the start and end dates displayed
     * to the user use {@link #getViewBounds}.
     * @return {Date} The start date
     */
    getStartDate: function() {
        return this.startDate;
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-setStartDate'>    /**
</span>     * Sets the start date used to calculate the view boundaries to display. The displayed view will be the
     * earliest and latest dates that match the view requirements and contain the date passed to this function.
     * @param {Date} dt The date used to calculate the new view boundaries
     */
    setStartDate: function(start, /*private*/reload) {
        var me = this;

        var startDate = Extensible.Date.add(Ext.Date.clearTime(start || new Date(), true));
        Extensible.log(&#39;setStartDate (base) &#39; + Ext.Date.format(startDate, &#39;Y-m-d G:i&#39;));

        var cloneDt = Ext.Date.clone,
            cloneStartDate = me.startDate ? cloneDt(me.startDate) : null,
            cloneViewStart = me.viewStart ? cloneDt(me.viewStart) : null,
            cloneViewEnd = me.viewEnd ? cloneDt(me.viewEnd) : null;

        if (me.fireEvent(&#39;beforedatechange&#39;, me, cloneStartDate, startDate, cloneViewStart, cloneViewEnd) !== false) {
            me.startDate = startDate;
            me.setViewBounds(startDate);

            if (me.ownerCalendarPanel &amp;&amp; me.ownerCalendarPanel.startDate !== me.startDate) {
                // Sync the owning CalendarPanel&#39;s start date directly, not via CalendarPanel.setStartDate(),
                // since that would in turn call this method again.
                me.ownerCalendarPanel.startDate = me.startDate;
            }

            if (me.rendered) {
                me.refresh(reload);
            }
            me.fireEvent(&#39;datechange&#39;, me, cloneDt(me.startDate), cloneDt(me.viewStart), cloneDt(me.viewEnd));
        }
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-setViewBounds'>    setViewBounds: function(startDate) {
</span>        var me = this,
            start = startDate || me.startDate,
            offset = start.getDay() - me.startDay;

        if (offset &lt; 0) {
            // if the offset is negative then some days will be in the previous week so add a week to the offset
            offset += 7;
        }
        switch(this.weekCount) {
            case 0:
            case 1:
                me.viewStart = me.dayCount &lt; 7 &amp;&amp; !me.startDayIsStatic ? start :
                    Extensible.Date.add(start, {days: -offset, clearTime: true});
                me.viewEnd = Extensible.Date.add(me.viewStart, {days: me.dayCount || 7, seconds: -1});
                break;

            case -1:
                // auto by month
                start = Ext.Date.getFirstDateOfMonth(start);
                offset = start.getDay() - me.startDay;
                if (offset &lt; 0) {
                    // if the offset is negative then some days will be in the previous week so add a week to the offset
                    offset += 7;
                }
                me.viewStart = Extensible.Date.add(start, {days: -offset, clearTime: true});

                // start from current month start, not view start:
                var end = Extensible.Date.add(start, {months: 1, seconds: -1});

                // fill out to the end of the week:
                offset = me.startDay;
                if (offset &gt; end.getDay()) {
                    // if the offset is larger than the end day index then the last row will be empty so skip it
                    offset -= 7;
                }

                me.viewEnd = Extensible.Date.add(end, {days: 6 - end.getDay() + offset});
                break;

            default:
                me.viewStart = Extensible.Date.add(start, {days: -offset, clearTime: true});
                me.viewEnd = Extensible.Date.add(me.viewStart, {days: me.weekCount * 7, seconds: -1});
                break;
        }
        Extensible.log(&#39;Set viewStart=&#39; + me.viewStart + &#39;, viewEnd=&#39; + me.viewEnd);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-getViewBounds'>    /**
</span>     * Returns the start and end boundary dates currently displayed in the view. The method
     * returns an object literal that contains the following properties:
     *
     *	* **start** Date: The start date of the view
     *	* **end** Date: The end date of the view
     *
     * For example:
     *		var bounds = view.getViewBounds();
     *		alert(&#39;Start: &#39;+bounds.start);
     *		alert(&#39;End: &#39;+bounds.end);
     * @return {Object} An object literal containing the start and end values
     */
    getViewBounds: function() {
        return {
            start: this.viewStart,
            end: this.viewEnd
        };
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-sortEventRecordsForDay'>    /* private
</span>     * Sort events for a single day for display in the calendar.  This sorts allday
     * events first, then non-allday events are sorted either based on event start
     * priority or span priority based on the value of {@link #spansHavePriority}
     * (defaults to event start priority).
     * @param {MixedCollection} evts A {@link Ext.util.MixedCollection MixedCollection}
     * of {@link #Extensible.calendar.data.EventModel EventRecord} objects
     */
    sortEventRecordsForDay: function(evts) {
        if (evts.length &lt; 2) {
            return;
        }
        evts.sortBy(Ext.bind(function(evtA, evtB) {
            var a = evtA.data,
                b = evtB.data,
                M = Extensible.calendar.data.EventMappings;

            // Always sort all day events before anything else
            if (a[M.IsAllDay.name]) {
                return -1;
            }
            else if (b[M.IsAllDay.name]) {
                return 1;
            }
            if (this.spansHavePriority) {
                // This logic always weights span events higher than non-span events
                // (at the possible expense of start time order). This seems to
                // be the approach used by Google calendar and can lead to a more
                // visually appealing layout in complex cases, but event order is
                // not guaranteed to be consistent.
                var diff = Extensible.Date.diffDays;
                if (diff(a[M.StartDate.name], a[M.EndDate.name]) &gt; 0) {
                    if (diff(b[M.StartDate.name], b[M.EndDate.name]) &gt; 0) {
                        // Both events are multi-day
                        if (a[M.StartDate.name].getTime() === b[M.StartDate.name].getTime()) {
                            // If both events start at the same time, sort the one
                            // that ends later (potentially longer span bar) first
                            return b[M.EndDate.name].getTime() - a[M.EndDate.name].getTime();
                        }
                        return a[M.StartDate.name].getTime() - b[M.StartDate.name].getTime();
                    }
                    return -1;
                }
                else if (diff(b[M.StartDate.name], b[M.EndDate.name]) &gt; 0) {
                    return 1;
                }
                return a[M.StartDate.name].getTime() - b[M.StartDate.name].getTime();
            }
            else {
                // Doing this allows span and non-span events to intermingle but
                // remain sorted sequentially by start time. This seems more proper
                // but can make for a less visually-compact layout when there are
                // many such events mixed together closely on the calendar.
                return a[M.StartDate.name].getTime() - b[M.StartDate.name].getTime();
            }
        }, this));
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-moveTo'>    /**
</span>     * Updates the view to contain the passed date
     * @param {Date} dt The date to display
     */
    moveTo: function(dt, /*private*/reload) {
        if (Ext.isDate(dt)) {
            this.setStartDate(dt, reload);
            return this.startDate;
        }
        return dt;
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-moveNext'>    /**
</span>     * Updates the view to the next consecutive date(s)
     * @return {Date} The new view start date
     */
    moveNext: function(/*private*/reload) {
        return this.moveTo(Extensible.Date.add(this.viewEnd, {days: 1}), reload);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-movePrev'>    /**
</span>     * Updates the view to the previous consecutive date(s)
     * @return {Date} The new view start date
     */
    movePrev: function(/*private*/reload) {
        var days = Extensible.Date.diffDays(this.viewStart, this.viewEnd)+1;
        return this.moveDays(-days, reload);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-moveMonths'>    /**
</span>     * Shifts the view by the passed number of months relative to the currently set date
     * @param {Number} value The number of months (positive or negative) by which to shift the view
     * @return {Date} The new view start date
     */
    moveMonths: function(value, /*private*/reload) {
        return this.moveTo(Extensible.Date.add(this.startDate, {months: value}), reload);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-moveWeeks'>    /**
</span>     * Shifts the view by the passed number of weeks relative to the currently set date
     * @param {Number} value The number of weeks (positive or negative) by which to shift the view
     * @return {Date} The new view start date
     */
    moveWeeks: function(value, /*private*/reload) {
        return this.moveTo(Extensible.Date.add(this.startDate, {days: value * 7}), reload);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-moveDays'>    /**
</span>     * Shifts the view by the passed number of days relative to the currently set date
     * @param {Number} value The number of days (positive or negative) by which to shift the view
     * @return {Date} The new view start date
     */
    moveDays: function(value, /*private*/reload) {
        return this.moveTo(Extensible.Date.add(this.startDate, {days: value}), reload);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-moveToday'>    /**
</span>     * Updates the view to show today
     * @return {Date} Today&#39;s date
     */
    moveToday: function(/*private*/reload) {
        return this.moveTo(new Date(), reload);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-setStore'>    /**
</span>     * Sets the event store used by the calendar to display {@link Extensible.calendar.data.EventModel events}.
     * @param {Ext.data.Store} store
     */
    setStore: function(store, initial) {
        var currStore = this.store;

        if (!initial &amp;&amp; currStore) {
            currStore.un(&quot;load&quot;, this.onEventStoreLoad, this);
            currStore.un(&quot;clear&quot;, this.refresh, this);
            currStore.un(&quot;write&quot;, this.onWrite, this);
            // Note that this handler is attached to the proxy&#39;s exception event. In Ext 4 the store no longer
            // raises an exception event. Store.sync() does accept a callback argument in 4.1+, but in 4.0.x
            // unfortunately the only way to handle this is directly on the proxy, so for ease of compatibility
            // that&#39;s what we&#39;re doing here.
            currStore.getProxy().un(&quot;exception&quot;, this.onException, this);
        }
        if (store) {
            store.on(&quot;load&quot;, this.onEventStoreLoad, this);
            store.on(&quot;clear&quot;, this.refresh, this);
            store.on(&quot;write&quot;, this.onWrite, this);
            store.getProxy().on(&quot;exception&quot;, this.onException, this);
        }
        this.store = store;
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-onEventStoreLoad'>    onEventStoreLoad: function(store, recs, successful) {
</span>        Extensible.log(&#39;AbstractCalendar.onEventStoreLoad: store loaded&#39;);
        this.refresh(false);
    },

<span id='Extensible-calendar-view-AbstractCalendar-property-onDataChanged'>    // No longer used, but kept here for compatibility
</span>    onDataChanged: this.onEventStoreLoad,

<span id='Extensible-calendar-view-AbstractCalendar-method-onException'>    /**
</span>     * This method handles internal housekeeping for cleaning up unsaved records in the store, and also
     * calls {@link #notifyOnException} to provide an easily overrideable mechanism for customizing if/how
     * the user should be notified when an error occurs.
     * @private
     */
    onException: function(proxy, response, operation) {
        // Form edits are explicitly canceled, but we may not know if a drag/drop operation
        // succeeded until after a server round trip. If the server action failed for any reason we have to
        // explicitly reject the changes so that the record doesn&#39;t stick around in the store&#39;s modified list
        // if the user cancels the action without successfully persisting the change to the server.
        Ext.each(operation.records, function(rec) {
            if (rec.dirty) {
                if (rec.phantom) {
                    this.store.remove(rec);
                }
                else {
                    rec.reject();
                }
            }
        }, this);

        if (this.fireEvent(&#39;eventexception&#39;, this, response, operation) !== false) {
            this.notifyOnException(response, operation);
        }
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-getExceptionMessage'>    /**
</span>     * Returns the message to display from {@link #notifyOnException}, generated automatically
     * from the server response and operation objects.
     * @protected
     * @since 1.6.0
     */
    getExceptionMessage: function(response, operation) {
        var msg = &#39;&#39;;

        if (response.responseText) {
            msg += &#39;&lt;br&gt;&lt;b&gt;responseText&lt;/b&gt;: &#39; + response.responseText;
        }
        if (response.message) {
            msg += &#39;&lt;br&gt;&lt;b&gt;message&lt;/b&gt;: &#39; + response.message;
        }
        if (response.status) {
            msg += &#39;&lt;br&gt;&lt;b&gt;status&lt;/b&gt;: &#39; + response.status;
        }
        if (response.statusText) {
            msg += &#39;&lt;br&gt;&lt;b&gt;statusText&lt;/b&gt;: &#39; + response.statusText;
        }
        if (operation.error &amp;&amp; operation.error.length) {
            msg += &#39;&lt;br&gt;&lt;b&gt;processing error&lt;/b&gt;: &#39; + operation.error;
        }

        return msg || (&#39;&lt;br&gt;&#39; + this.notifyOnExceptionDefaultMessage);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-notifyOnException'>    /**
</span>     * This is an overrideable method for notifying the user when an exception occurs while attempting to
     * process records via a proxy. The default implementation is to display a standard Ext MessageBox with
     * the returned error message, but you can override this method to provide any desired notification.
     *
     * Note that the view will also raise the {@link #eventexception} event automatically. Event handling
     * functions can return false to bypass this method if application-specific code might conditionally
     * handle exceptions, and still fall back to this method in other cases. To bypass this method globally
     * you can simply remove it like so (or you could do the same thing in a view subclass):
     *		Ext.override(Extensible.calendar.view.AbstractCalendar, {
     *			notifyOnException: Ext.emptyFn
     *		});
     * @param {Object} response The raw response object returned from the server
     * @param {Ext.data.Operation} operation The operation that was processed
     * @since 1.6.0
     */
    notifyOnException: function(response, operation) {
        Ext.Msg.alert(this.notifyOnExceptionTitle, this.notifyOnExceptionText + &#39;&lt;br&gt;&#39; +
            this.getExceptionMessage(response, operation));
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-setCalendarStore'>    /**
</span>     * Sets the calendar store used by the calendar (contains records of type {@link Extensible.calendar.data.CalendarModel CalendarRecord}).
     * @param {Ext.data.Store} store
     */
    setCalendarStore: function(store, initial) {
        if (!initial &amp;&amp; this.calendarStore) {
            this.calendarStore.un(&quot;datachanged&quot;, this.refresh, this);
            this.calendarStore.un(&quot;add&quot;, this.refresh, this);
            this.calendarStore.un(&quot;remove&quot;, this.refresh, this);
            this.calendarStore.un(&quot;update&quot;, this.refresh, this);
        }
        if (store) {
            store.on(&quot;datachanged&quot;, this.refresh, this);
            store.on(&quot;add&quot;, this.refresh, this);
            store.on(&quot;remove&quot;, this.refresh, this);
            store.on(&quot;update&quot;, this.refresh, this);
        }
        this.calendarStore = store;
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-getEventRecord'>    getEventRecord: function(id) {
</span>        var idx = this.store.find(Extensible.calendar.data.EventMappings.EventId.name, id,
            0,     // start index
            false, // match any part of string
            true,  // case sensitive
            true   // force exact match
        );
        return this.store.getAt(idx);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-getEventRecordFromEl'>    getEventRecordFromEl: function(el) {
</span>        return this.getEventRecord(this.getEventIdFromEl(el));
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-getEventEditor'>    getEventEditor: function() {
</span>        // only create one instance of the edit window, even if there are multiple CalendarPanels
        this.editWin = this.editWin || Ext.WindowMgr.get(&#39;ext-cal-editwin&#39;);

        if (!this.editWin) {
            this.editWin = Ext.create(&#39;Extensible.calendar.form.EventWindow&#39;, {
                id: &#39;ext-cal-editwin&#39;,
                calendarStore: this.calendarStore,
                modal: this.editModal,
                enableEditDetails: this.enableEditDetails,
                startDay: this.startDay,

                listeners: {
                    &#39;eventadd&#39;: {
                        fn: function(win, rec, animTarget, options) {
                            //win.hide(animTarget);
                            win.currentView.onEventEditorAdd(null, rec, options);
                        },
                        scope: this
                    },
                    &#39;eventupdate&#39;: {
                        fn: function(win, rec, animTarget, options) {
                            //win.hide(animTarget);
                            win.currentView.onEventEditorUpdate(null, rec, options);
                        },
                        scope: this
                    },
                    &#39;eventdelete&#39;: {
                        fn: function(win, rec, animTarget, options) {
                            //win.hide(animTarget);
                            win.currentView.onEventEditorDelete(null, rec, options);
                        },
                        scope: this
                    },
                    &#39;editdetails&#39;: {
                        fn: function(win, rec, animTarget, view) {
                            // explicitly do not animate the hide when switching to detail
                            // view as it looks weird visually
                            win.animateTarget = null;
                            win.hide();
                            win.currentView.fireEvent(&#39;editdetails&#39;, win.currentView, rec);
                        },
                        scope: this
                    },
                    &#39;eventcancel&#39;: {
                        fn: function(win, rec, animTarget) {
                            this.dismissEventEditor(null, animTarget);
                            win.currentView.onEventEditorCancel();
                        },
                        scope: this
                    }
                }
            });
        }

        // allows the window to reference the current scope in its callbacks
        this.editWin.currentView = this;
        return this.editWin;
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-showEventEditor'>    /**
</span>     * Show the currently configured event editor view (by default the shared instance of
     * {@link Extensible.calendar.form.EventWindow EventEditWindow}).
     * @param {Extensible.calendar.data.EventModel} rec The event record
     * @param {Ext.Element/HTMLNode} animateTarget The reference element that is being edited. By default this is
     * used as the target for animating the editor window opening and closing. If this method is being overridden to
     * supply a custom editor this parameter can be ignored if it does not apply.
     * @return {Extensible.calendar.view.AbstractCalendar} this
     */
    showEventEditor: function(rec, animateTarget) {
        this.getEventEditor().show(rec, animateTarget, this);
        return this;
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-dismissEventEditor'>    /**
</span>     * Dismiss the currently configured event editor view (by default the shared instance of
     * {@link Extensible.calendar.form.EventWindow EventEditWindow}, which will be hidden).
     * @param {String} dismissMethod (optional) The method name to call on the editor that will dismiss it
     * (defaults to &#39;hide&#39; which will be called on the default editor window)
     * @return {Extensible.calendar.view.AbstractCalendar} this
     */
    dismissEventEditor: function(dismissMethod, /*private*/ animTarget) {
        if (this.newRecord &amp;&amp; this.newRecord.phantom) {
            this.store.remove(this.newRecord);
        }
        delete this.newRecord;

        // grab the manager&#39;s ref so that we dismiss it properly even if the active view has changed
        var editWin = Ext.WindowMgr.get(&#39;ext-cal-editwin&#39;);
        if (editWin) {
            editWin[dismissMethod ? dismissMethod : &#39;hide&#39;](animTarget);
        }
        return this;
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-save'>    save: function() {
</span>        // If the store is configured as autoSync:true the record&#39;s endEdit
        // method will have already internally caused a save to execute on
        // the store. We only need to save manually when autoSync is false,
        // otherwise we&#39;ll create duplicate transactions.
        if (!this.store.autoSync) {
            this.store.sync();
        }
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-onWrite'>    onWrite: function(store, operation) {
</span>        if (operation.wasSuccessful()) {
            //var rec = operation.records[0];

            switch(operation.action) {
                case &#39;create&#39;:
                    this.onAdd(store, operation);
                    break;
                case &#39;update&#39;:
                    this.onUpdate(store, operation, Ext.data.Record.COMMIT);
                    break;
                case &#39;destroy&#39;:
                    this.onRemove(store, operation);
                    break;
            }
        }
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-onEventEditorAdd'>    onEventEditorAdd: function(form, rec) {
</span>        this.newRecord = rec;

        if (this.store.indexOf(rec) === -1) {
            this.store.add(rec);
        }
        this.save();
        this.fireEvent(&#39;eventadd&#39;, this, rec);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-onEventEditorUpdate'>    onEventEditorUpdate: function(form, rec) {
</span>        this.save();
        this.fireEvent(&#39;eventupdate&#39;, this, rec);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-onEventEditorDelete'>    onEventEditorDelete: function(form, rec) {
</span>        rec._deleting = true;
        this.deleteEvent(rec);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-onEventEditorCancel'>    onEventEditorCancel: function(form, rec) {
</span>        this.fireEvent(&#39;eventcancel&#39;, this, rec);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-onDayClick'>    // called from subclasses
</span>    onDayClick: function(dt, ad, el) {
        if (this.readOnly === true) {
            return;
        }
        if (this.fireEvent(&#39;dayclick&#39;, this, Ext.Date.clone(dt), ad, el) !== false) {
            var M = Extensible.calendar.data.EventMappings,
                data = {};

            data[M.StartDate.name] = dt;
            data[M.IsAllDay.name] = ad;

            this.showEventEditor(data, el);
        }
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-showEventMenu'>    showEventMenu: function(el, xy) {
</span>        var me = this;

        if (!me.eventMenu) {
            me.eventMenu = Ext.create(&#39;Extensible.calendar.menu.Event&#39;, {
                startDay: me.startDay,
                ownerCalendarPanel: me,
                listeners: {
                    &#39;editdetails&#39;: Ext.bind(me.onEditDetails, me),
                    &#39;eventdelete&#39;: Ext.bind(me.onDeleteEvent, me),
                    &#39;eventmove&#39;  : Ext.bind(me.onMoveEvent, me),
                    &#39;eventcopy&#39;  : Ext.bind(me.onCopyEvent, me)
                }
            });
        }

        me.eventMenu.showForEvent(me.getEventRecordFromEl(el), el, xy);
        me.menuActive = true;
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-onCopyEvent'>    onCopyEvent: function(menu, rec, newStartDate) {
</span>        this.menuActive = false;
        this.shiftEvent(rec, newStartDate, &#39;copy&#39;);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-onMoveEvent'>    onMoveEvent: function(menu, rec, newStartDate) {
</span>        this.menuActive = false;
        this.shiftEvent(rec, newStartDate, &#39;move&#39;);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-copyEvent'>    /**
</span>     * Create a copy of the event with a new start date, preserving the original event duration.
     * @param {Object} rec The original event {@link Extensible.calendar.data.EventModel record}
     * @param {Object} newStartDate The new start date. The end date of the created event copy will be adjusted
     * automatically to preserve the original duration.
     */
    copyEvent: function(rec, newStartDate) {
        this.shiftEvent(rec, newStartDate, &#39;copy&#39;);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-moveEvent'>    /**
</span>     * Move the event to a new start date, preserving the original event duration.
     * @param {Object} rec The event {@link Extensible.calendar.data.EventModel record}
     * @param {Object} newStartDate The new start date
     */
    moveEvent: function(rec, newStartDate) {
        this.shiftEvent(rec, newStartDate, &#39;move&#39;);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-shiftEvent'>    shiftEvent: function(rec, newStartDate, moveOrCopy) {
</span>        var me = this,
            newRec;

        if (moveOrCopy === &#39;move&#39;) {
            if (Extensible.Date.compare(rec.getStartDate(), newStartDate) === 0) {
                // No changes, so we aren&#39;t actually moving. Copying to the same date is OK.
                return;
            }
            newRec = rec;
        }
        else {
            newRec = rec.clone();
        }

        if (me.fireEvent(&#39;beforeevent&#39; + moveOrCopy, me, newRec, Ext.Date.clone(newStartDate)) !== false) {
            if (newRec.isRecurring()) {
                //if (me.recurrenceOptions.editSingleOnDrag) {
                    me.onRecurrenceEditModeSelected(&#39;single&#39;, newRec, newStartDate, moveOrCopy);
                //}
                // else {
                    // Extensible.form.recurrence.RangeEditWindow.prompt({
                        // callback: Ext.bind(me.onRecurrenceEditModeSelected, me, [newRec, newStartDate, moveOrCopy], true),
                        // editModes: [&#39;single&#39;, &#39;future&#39;],
                        // scope: me
                    // });
                // }
            }
            else {
                me.doShiftEvent(newRec, newStartDate, moveOrCopy);
            }
        }
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-onRecurrenceEditModeSelected'>    onRecurrenceEditModeSelected: function(editMode, rec, newStartDate, moveOrCopy) {
</span>        var EventMappings = Extensible.calendar.data.EventMappings;

        if (editMode) {
            if (moveOrCopy === &#39;copy&#39;) {
                rec.clearRecurrence();
            }
            rec.data[EventMappings.REditMode.name] = editMode;
            rec.data[EventMappings.RInstanceStartDate.name] = rec.getStartDate();
            this.doShiftEvent(rec, newStartDate, moveOrCopy);
        }
        // else user canceled
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-doShiftEvent'>    doShiftEvent: function(rec, newStartDate, moveOrCopy) {
</span>        var EventMappings = Extensible.calendar.data.EventMappings,
            startDiff = Extensible.Date.diff(rec.getStartDate(), newStartDate),
            newEndDate = Extensible.Date.add(rec.getEndDate(), {millis: startDiff}),
            timezoneOffset = Extensible.Date.diffTimezones(rec.getEndDate(), newEndDate),
            updateData = {};

        if (timezoneOffset) {
            newEndDate = Extensible.Date.add(newEndDate, {minutes: -timezoneOffset});
        }
        updateData[EventMappings.StartDate.name] = newStartDate;
        updateData[EventMappings.EndDate.name] = newEndDate;
        rec.set(updateData);

        if (rec.phantom) {
            this.store.add(rec);
        }

        this.save();
        this.fireEvent(&#39;event&#39; + moveOrCopy, this, rec);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-onEditDetails'>    onEditDetails: function(menu, rec, el) {
</span>        this.fireEvent(&#39;editdetails&#39;, this, rec, el);
        this.menuActive = false;
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-onDeleteEvent'>    // onRecurrenceMoveModeSelected: function(editMode, rec, newStartDate) {
</span>        // if (editMode) {
            // rec.data[Extensible.calendar.data.EventMappings.REditMode.name] = editMode;
            // rec.data[Extensible.calendar.data.EventMappings.RInstanceStartDate.name] = rec.getStartDate();
            // this.doShiftEvent(rec, newStartDate, &#39;move&#39;);
        // }
        // // else user canceled
    // },

    onDeleteEvent: function(menu, rec, el) {
        rec._deleting = true;
        this.deleteEvent(rec, el);
        this.menuActive = false;
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-deleteEvent'>    /**
</span>     * Delete the specified event.
     * @param {Object} rec The event {@link Extensible.calendar.data.EventModel record}
     */
    deleteEvent: function(rec, /* private */el) {
        var me = this;

        if (me.fireEvent(&#39;beforeeventdelete&#39;, me, rec, el) !== false) {
            if (rec.isRecurring()) {
                this.rangeEditWin = this.rangeEditWin || Ext.WindowMgr.get(&#39;ext-cal-rangeeditwin&#39;);
                if (!this.rangeEditWin) {
                    this.rangeEditWin = new Extensible.form.recurrence.RangeEditWindow();
                }
                this.rangeEditWin.prompt({
                    callback: Ext.bind(me.onRecurrenceDeleteModeSelected, me, [rec, el], true),
                    scope: me
                });
            }
            else {
                me.doDeleteEvent(rec, el);
            }
        }
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-onRecurrenceDeleteModeSelected'>    onRecurrenceDeleteModeSelected: function(editMode, rec, el) {
</span>        if (editMode) {
            rec.data[Extensible.calendar.data.EventMappings.REditMode.name] = editMode;
            rec.data[Extensible.calendar.data.EventMappings.RInstanceStartDate.name] = rec.getStartDate();
            this.doDeleteEvent(rec, el);
        }
        // else user canceled
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-doDeleteEvent'>    doDeleteEvent: function(rec, /* private */el) {
</span>        this.store.remove(rec);
        this.save();
        this.fireEvent(&#39;eventdelete&#39;, this, rec, el);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-onContextMenu'>    onContextMenu: function(e, t) {
</span>        var el = e.getTarget(this.eventSelector, 5, true),
            match = false;

        if (el) {
            this.dismissEventEditor().showEventMenu(el, e.getXY());
            match = true;
        }

        if (match || this.suppressBrowserContextMenu === true) {
            e.preventDefault();
        }
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-onClick'>    /*
</span>     * Shared click handling.  Each specific view also provides view-specific
     * click handling that calls this first.  This method returns true if it
     * can handle the click (and so the subclass should ignore it) else false.
     */
    onClick: function(e, t) {
        var me = this,
            el = e.getTarget(me.eventSelector, 5);

        if (me.dropZone) {
            me.dropZone.clearShims();
        }
        if (me.menuActive === true) {
            // ignore the first click if a context menu is active (let it close)
            me.menuActive = false;
            return true;
        }
        if (el) {
            var id = me.getEventIdFromEl(el),
                rec = me.getEventRecord(id);

            if (rec &amp;&amp; me.fireEvent(&#39;eventclick&#39;, me, rec, el) !== false) {
                if (me.readOnly !== true) {
                    me.showEventEditor(rec, el);
                }
            }
            return true;
        }
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-onMouseOver'>    onMouseOver: function(e, t) {
</span>        if (this.trackMouseOver !== false &amp;&amp; (this.dragZone === undefined || !this.dragZone.dragging)) {
            if (!this.handleEventMouseEvent(e, t, &#39;over&#39;)) {
                this.handleDayMouseEvent(e, t, &#39;over&#39;);
            }
        }
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-onMouseOut'>    onMouseOut: function(e, t) {
</span>        if (this.trackMouseOver !== false &amp;&amp; (this.dragZone === undefined || !this.dragZone.dragging)) {
            if (!this.handleEventMouseEvent(e, t, &#39;out&#39;)) {
                this.handleDayMouseEvent(e, t, &#39;out&#39;);
            }
        }
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-handleEventMouseEvent'>    handleEventMouseEvent: function(e, t, type) {
</span>        var el = e.getTarget(this.eventSelector, this.eventSelectorDepth, true);

        if (el) {
            var rel = Ext.get(e.getRelatedTarget());

            if (el === rel || el.contains(rel)) {
                return true;
            }

            var evtId = this.getEventIdFromEl(el);

            if (this.eventOverClass !== &#39;&#39;) {
                var els = this.getEventEls(evtId);
                els[type === &#39;over&#39; ? &#39;addCls&#39; : &#39;removeCls&#39;](this.eventOverClass);
            }

            this.fireEvent(&#39;event&#39; + type, this, this.getEventRecord(evtId), el);

            return true;
        }
        return false;
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-getDateFromId'>    getDateFromId: function(id, delim) {
</span>        var parts = id.split(delim);
        return parts[parts.length-1];
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-handleDayMouseEvent'>    handleDayMouseEvent: function(e, t, type) {
</span>        t = e.getTarget(&#39;td&#39;, 3);

        if (t) {
            if (t.id &amp;&amp; t.id.indexOf(this.dayElIdDelimiter) &gt; -1) {
                var dt = this.getDateFromId(t.id, this.dayElIdDelimiter),
                    rel = Ext.get(e.getRelatedTarget()),
                    relTD, relDate;

                if (rel) {
                    relTD = rel.is(&#39;td&#39;) ? rel : rel.up(&#39;td&#39;, 3);
                    relDate = relTD &amp;&amp; relTD.id ? this.getDateFromId(relTD.id, this.dayElIdDelimiter) : &#39;&#39;;
                }
                if (!rel || dt !== relDate) {
                    var el = this.getDayEl(dt);

                    if (el &amp;&amp; !Ext.isEmpty(this.dayOverClass)) {
                        el[type === &#39;over&#39; ? &#39;addCls&#39; : &#39;removeCls&#39;](this.dayOverClass);
                    }
                    var parsedDate = Ext.Date.parseDate(dt + &#39; 12:00&#39;, &#39;Ymd G:i&#39;);
                    this.fireEvent(&#39;day&#39; + type, this, parsedDate, el);
                }
            }
        }
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-renderItems'>    // MUST be implemented by subclasses
</span>    renderItems: function() {
        throw new Error(&#39;The renderItems method must be implemented by a subclass&#39;);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-isActiveView'>    /**
</span>     * Returns true only if this is the active view inside of an owning
     * {@link Extensible.calendar.CalendarPanel CalendarPanel}. If it is not active, or
     * not hosted inside a CalendarPanel, returns false.
     * @return {Boolean} True if this is the active CalendarPanel view, else false
     * @since 1.6.0
     */
    isActiveView: function() {
        var calendarPanel = this.ownerCalendarPanel;
        return (calendarPanel &amp;&amp; calendarPanel.getActiveView().id === this.id);
    },

<span id='Extensible-calendar-view-AbstractCalendar-method-destroy'>    destroy: function() {
</span>        this.callParent(arguments);

        if (this.el) {
            this.el.un(&#39;contextmenu&#39;, this.onContextMenu, this);
        }
        Ext.destroy(
            this.editWin,
            this.eventMenu,
            this.dragZone,
            this.dropZone
        );
    }
});
</pre>
</body>
</html>
